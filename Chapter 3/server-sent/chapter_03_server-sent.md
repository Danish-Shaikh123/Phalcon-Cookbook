
## Creating a server-sent message server

The server-sent event API is a new great alternative to using AJAX to long poll the server for updates.  This new API has a very simple Javascript interface as well as an easy to understand server implementation and it is also more efficient while having a built in reconnection feature.  If your application requires a simple data feed or there is a need for a rapid prototype then the server-sent API might be the ideal choice.

#### Getting Ready...

To use this recipe you will need to have a project skeleton with a configured Phalcon bootstraper, \Phalcon\Mvc\Router and at least one \Phalcon\Mvc\Controler.  In our example we will use a project scaffold generated by **Phalcon Developer Tools**.

For testing the recipe results you need to have a web server installed and configured for handling requests to your application. Your application must be able to take requests, and additionally, there must be such necessary components as Controllers, Views, and a bootstrap-file.

A database is not required for this recipe.

#### How to do it...

Follow these steps to complete this recipeâ€¦

1) First of all, we need to have an application which we will experiment with. If you already have such an application, you can skip this step. Create a simple application: `phalcon project server-sent simple`.  

2) Now point the web browser at the root directory of the project. There should be a page with "Congratulations! ....".  If we see the *Volt directory can't be written* error message then permissions of the directory `app/cache` needs to be changed to allow the web server to write to it.

3) Create the controller `/app/controllers/MessagesController.php`.

```php
<?php

class MessagesController extends ControllerBase
{

    public function indexAction()
    {

    }

    public function retrieveAction()
    {
        $this->response->setHeader("Content-Type", "text/event-stream");
        $this->response->send();
        $this->view->disable();

        // Remove one level of output buffering
        ob_get_clean();

        $count = 0;
        while ($count < 3) {
            $count++;

            // Send the 'update' event
            echo "event: update\n";
            echo 'data: {"time": "' . date(DATE_ISO8601) . '"}';
            echo "\n\n";

            ob_flush();
            flush();
            sleep(2);
        }
    }
}
```

4) Create the view `app/views/messages/index.volt`.

```html
<div id="messages"></div>

<script>
  var messages = document.getElementById('messages')

  var evtSource = new EventSource("messages/retrieve");
  evtSource.addEventListener("phalcon-message", function(e) {
    var data = JSON.parse(e.data);

    var newElement = document.createElement("li");
    newElement.innerHTML = data.time;
    messages.appendChild(newElement);
  }, false);
</script>
```

5) Point the web browser at the path `messages` to load the Javascript which will create the EventSource object to retrieve the server-sent messages at path `messages/retrieve`.

#### How it Works...

When the browser is pointed at path `messages` it loads the view that we have placed in directory `app/views/messages/index.volt`.  This view loads the HTML fragment `<div id="messages"></div>` which is where we will place the time of day from each new data update.

```Javascript
  var evtSource = new EventSource("messages/retrieve");
```

This creates an EventSource object which implements the server-sent message API.  This will then connect to our Phalcon framework at the "message/retrieve" path which is automatically directed by the default routing to the retrieveAction method on the MessagesController.

We then listen to any "phalcon-message" events coming from this connection.  Then delving into this event listener we are simply converting the JSON string into a plain object and then appending the "time" property into the HTML so that we can visibly track the updates.

Now we are ready to investigate the PHP code in the MessagesController that is responsible for sending these messages.

First in order to allow the browser EventSource to recognize the stream we must set the response header content type to "text/event-stream".  Then we send the header to the browser and this must be done before any data is received by the browser.  We are using the normal Phalcon dependency injected response for this instead of directly calling the PHP function `header` so that we do not circumvent the normal operations of our Phalcon system.  It is possible for other components our the system to set additional headers during the dispatch cycle and some of these could be important security features that could be dangerous to omit.

```PHP
$this->response->setHeader("Content-Type", "text/event-stream");
$this->response->send();
```

As an additional precaution we disable the view rendering to ensure that we do not receive warnings in our logs or accidentally output a view if there is an error later.

```php
$this->view->disable();
```

Now we are ready to speak about output buffering.  In the vast majority of cases in a Phalcon application we want the normal operation cycle to handle the actual transmitting of data so that it is efficiently sent all at once at the end of the request handling.  This common assumption doesn't work well for a server-sent message because the entire point is to deliver timely updates to the browser.  If we don't first address output buffering then all of the text that we output to the browser won't actually be sent until the very end of the request handling and so all of the messages will be delivered all at once.  In order to gain direct access to the first output buffer we will need to destroy the second level of buffering.

```php
// Remove one level of output buffering
ob_get_clean();
```

Now we are at a level of output buffering in which we can precisely determine when data is transmitted to the browser.  We will iterate on our loop 3 times and during each iteration we will send a message to the browser so that it can be caught by the Javascript event handler that we added.

The simplicity of the server-sent event API is that a complete message package can be sent with just the three lines of code.  We are defining an event called "phalcon-message" and then we are including data with it and then finally ending it with double newline characters "\n\n" to indicate that the message is complete.  You can read more about it at:

 https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events

```php
// Send the 'update' event
echo "event: phalcon-message\n";
echo 'data: {"time": "' . date(DATE_ISO8601) . '"}';
echo "\n\n";
```

However we are done quite done yet because the data is stuck in the output buffer and has not yet been transmitted to the browser.  We can flush this data to the browser with the following code:

```php
ob_flush();
flush();
```

At the end of the loop we will make the execution stop with `sleep(1)`.  This will have the effect of sending a total of three messages with a pause of one second after each message.

Now we will take a step back to analyze the behavior every script cycle.  First Javascript in the browser connects to our Phalcon server and the result is that a total of three messages are sent to the browser.  After this happens the PHP script dies and we can see a period of several seconds in which no new messages are received and then just as suddenly as it ended the messages start appearing again.  This is a result of the automatic reconnection feature of the server-sent message API.  So users can connect once and a tiny network hiccup won't break the functionality.
