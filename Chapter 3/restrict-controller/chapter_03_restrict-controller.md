
## Restricting controllers by managing end user privileges

Every serious app needs to be able to control access to the logical processes within its framework.  Using Phalcon we can easily create a security system to control access to resources based upon group membership.  In this recipe we will define resources as controller-action pairs but the primitives o the permission system are broad enough that with a little work the resources could be broadened to be anything.  In our case the idea of restricting resources (controller actions) is simple: if a user's group does not have permission to access an action then we will display the message "Unauthorized access".  Later this could be extended to forward the use to a sign in page or to an alternative page for that resource.

#### Getting Ready...

To use this recipe you will need to have a project skeleton with a configured Phalcon bootstraper, \Phalcon\Mvc\Router, \Phalcon\Acl\Adapter\Memory and at a few \Phalcon\Mvc\Controler.  In our example we will use a project scaffold generated by **Phalcon Developer Tools**.

For testing the recipe results you need to have a web server installed and configured for handling requests to your application. Your application must be able to take requests, and additionally, there must be such necessary components as Controllers, Views, and a bootstrap-file.

A database is not required for this recipe.

#### How to do it...
Follow these steps to complete this recipeâ€¦

1) We need to have an application which we will experiment with. If you already have such an application, you can skip this step. Create a simple application: `phalcon project restrict-controller simple`.

2) Now point the web browser at the root directory of the project. There should be a page with "Congratulations! ....".  If we see the *Volt directory can't be written* error message then permissions of the directory `app/cache` needs to be changed to allow the web server to write to it.

3)

Change loaders `app/config/loader.php`
```php
<?php
$loader = new \Phalcon\Loader();
$loader->registerDirs([
    $config->application->controllersDir,
    $config->application->modelsDir,
    $config->application->pluginsDir
])->register();
```

Attach DispatcherSecurity to the EventsManager service `app/config/services.php`
```php
<?php

$di->setShared('dispatcher', function() {
    $securityPlugin = new DispatcherSecurity();
    $securityPlugin->setDI($this);

    $eventsManager = $this->getEventsManager();
    $eventsManager->attach('dispatch', $securityPlugin);

    $dispatcher = new Phalcon\Mvc\Dispatcher();
    $dispatcher->setEventsManager($eventsManager);

    return $dispatcher;
});

$di->setShared('session', function () {
    $session = new Phalcon\Session\Adapter\File();
    $session->start();
    return $session;
});

$di->setShared('acl', function () use ($config) {
    $acl = require_once(__DIR__ . '/acl.php');
    return $acl;
});
```

Add file `app/plugins/DispatcherSecurity.php`
```php
<?php

class DispatcherSecurity extends Phalcon\Mvc\User\Plugin
{
    public function beforeExecuteRoute(Phalcon\Events\Event $event, Phalcon\Mvc\Dispatcher $dispatcher)
    {
        $roleName = ($this->session->has('role')) ? $this->session->get('role') : 'Annonymous';
        $controllerName = $dispatcher->getControllerName();
        $actionName = $dispatcher->getActionName();

        if (!$this->acl->isAllowed($roleName, $controllerName, $actionName)) {
            $this->response->setContent('Unauthorized access.');
            $this->response->send();

            return false;
        }
    }
}
```

Add `app/controllers/ProfileController.php`:

```php
<?php

class ProfileController extends \Phalcon\Mvc\Controller
{
    public function indexAction()
    {
        return 'Only signed in users should be able to change their profile';
    }
}
```

```php
<?php

class SecretController extends \Phalcon\Mvc\Controller
{
    public function dataAction()
    {
        return 'Only very important users should be able to access Secret Data.';
    }
}
```

Add `app/controllers/SessionController.php`:

```php
<?php

class SessionController extends \Phalcon\Mvc\Controller
{
    public function signinAsAdministratorsRoleAction()
    {
        $this->session->set('role', 'Administrators');

        return "You are now signed in with the 'Administrators' role.";
    }

    public function signinAsMembersRoleAction()
    {
        $this->session->set('role', 'Members');

        return "You are now signed in with the 'Members' role";
    }

    public function signoutAction()
    {
        $this->session->remove('role');

        return "You have successfully signed out.";
    }
}
```

Create `app/config/acl.php`

```php
<?php

$resources = [
    'index'    => ['index'],
    'session'  => ['index', 'signin', 'signout'],
    'profile'  => ['index'],
    'secret'   => ['data'],
];

$publicResources = [
    'index' => '*',
    'session' => '*'
];

$roles = [
    'Administrators' => [
        'profile'  => ['index'],
        'secret'   => ['data'],
    ],
    'Members' => [
        'profile'  => ['index']
    ],
    'Annonymous' => []
];

$acl = new Phalcon\Acl\Adapter\Memory();
$acl->setDefaultAction(Phalcon\Acl::DENY);

// Add all of the resources to the ACL
foreach ($resources as $controllerName => $actionList) {
    $acl->addResource(new Phalcon\Acl\Resource($controllerName), $actionList);
}

// Set the roles and allow specific access for actions
foreach ($roles as $roleName => $role) {
    $acl->addRole($roleName);
    foreach ($role as $controllerName => $actionList) {
        $acl->allow($roleName, $controllerName, $actionList);
    }
}

// Make public resources available to all roles
foreach ($publicResources as $controllerName => $actionList) {
    foreach ($roles as $roleName => $role) {
        $acl->allow($roleName, $controllerName, $actionList);
    }
}

return $acl;
```

#### How it Works...

In our loaders config we add the following line `$config->application->pluginsDir` to the registerDirs call to allow autoloading of our security plugin.

Then in `app/config/services.php` we define the "dispatcher" service.  Note that because this service is core to the system it will be automatically created by Phalcon if we have not defined it before it is needed the first time.

First we will need to define the ACL service that we will use later in our security plugin.  We will pull in the ACL object from the `acl.php` config file.

$di->setShared('acl', function () use ($config) {
    $acl = require_once(__DIR__ . '/acl.php');
    return $acl;
});

Then in app/config/acl.php there are three important declaration $resources, $publicResources and $roles.  First we must list all controller actions in $resources and every time that a new controller or action is added to the system then we must add it here as well.  Then if we would like a controller-action to always be allowed we can add it to $publicResources.  Finally in $roles we allow specific user roles to be allowed access to individual resources.

Next we create the actual ACL object and then we set its default action to deny first to prevent accidental mistakes in our ACL configuration.

    $acl = new Phalcon\Acl\Adapter\Memory();
    $acl->setDefaultAction(Phalcon\Acl::DENY);

Now that we have a functioning ACL system we will create a new instance of the DispatcherSecurity plugin and then set its dependency injector to $this since the service closure is bound to the DI.

$di->setShared('dispatcher', function() {
    $securityPlugin = new DispatcherSecurity();
    $securityPlugin->setDI($this);

Then we will access the "EventsManager" service to get the object and then we will attach the DispatcherException object to it so that it will receive notifications of events related to "dispatch".

    $eventsManager = $this->getEventsManager();
    $eventsManager->attach('dispatch', $exceptionPlugin);

Finally we will create a new Dispatcher and then attach the EventsManager object to it.  This allows the dispatchers events to be available to other components.

    $dispatcher = new Phalcon\Mvc\Dispatcher();
    $dispatcher->setEventsManager($eventsManager);

Now that we have setup the dispatcher we will take a look at the DispatcherSecurity plugin.  We have added a beforeExecuteRoute method so that the security plugin can implement logic before allowing the execution to continue to the route destination (controller-action) pair.

    public function beforeExecuteRoute(Event $event, Dispatcher $dispatcher)

Next we will check to see if the session variable "role" has been set and if not then we will make the default role to be "Annonymous".  Note that by requesting the session service the PHP session is automatically started.  Then we obtain the controller and action name since in our permission scheme we are defining these as the resource.

        $roleName = ($this->session->has('role')) ? $this->session->get('role') : 'Annonymous';
        $controllerName = $dispatcher->getControllerName();
        $actionName = $dispatcher->getActionName();

Next we will access the "acl" service and ask it to determine if the role can access the resource and we will cancel the route if it fails.

        if (!$this->acl->isAllowed($roleName, $controllerName, $actionName)) {
            $this->response->setContent('Unauthorized access.');
            $this->response->send();
            return false;
        }
